import path from "path";
import {
  Project,
  ClassDeclaration,
  PropertyDeclaration,
  type PropertySignatureStructure,
  type OptionalKind,
} from "ts-morph";

class ClassIndex extends Map<string, ClassDeclaration> {}

const ENTITY_SUFFIX = "Entity";
const DTO_SUFFIX = "DTO";

const ARRAY_WRAPPER_TYPE = new Set(["Array", "Collection"]);

const WRAPPER_TYPES = new Set([
  ...ARRAY_WRAPPER_TYPE,
  "Ref",
  "Reference",
  "IdentifiedReference",
  "Rel",
]);

function intersectProps(
  entityProps: OptionalKind<PropertySignatureStructure>[],
  dtoProps: OptionalKind<PropertySignatureStructure>[],
): OptionalKind<PropertySignatureStructure>[] {
  const dtoPropNameToProp = new Map(dtoProps.map((p) => [p.name, p]));

  return entityProps.filter((p) => {
    const dto = dtoPropNameToProp.get(p.name);
    if (!dto) {
      console.log("No prop named: ", p.name);
      return false;
    }

    if (p.type !== dto.type) {
      console.log(p.name + ": " + p.type + " <> " + dto.type);
    }
    // Must have exactly the same type to be included.
    return p.type === dto.type;
  });
}

function normalizeProperty(
  prop: PropertyDeclaration,
): OptionalKind<PropertySignatureStructure> {
  const type = prop.getType();
  const originalProp: OptionalKind<PropertySignatureStructure> = {
    name: prop.getName(),
    type: type.getText(),
    hasQuestionToken: prop.hasQuestionToken(),
  };

  const symbol = type.getSymbol();
  // No symbol means this is a raw type.
  if (!symbol) {
    return originalProp;
  }

  const isWrapper = WRAPPER_TYPES.has(symbol.getName());

  if (!isWrapper) {
    return originalProp;
  }

  const innerType = type.getTypeArguments()[0];
  if (!innerType) {
    throw new Error("Missing inner type for wrapper type.");
  }

  const typeWithAnyArrayWrapperApplied = ARRAY_WRAPPER_TYPE.has(
    symbol.getName(),
  )
    ? `(${innerType.getText()})[]`
    : innerType.getText();

  return {
    ...originalProp,
    type: typeWithAnyArrayWrapperApplied,
  };
}

function getClassIndex(project: Project, rootDir: string): ClassIndex {
  const classIndex = new ClassIndex();
  for (const sourceFile of project.getSourceFiles()) {
    // If this file isn't in the current project, ignore it.
    if (!sourceFile.getFilePath().startsWith(rootDir)) {
      continue;
    }
    for (const cls of sourceFile.getClasses()) {
      const clsName = cls.getName();
      if (!clsName) {
        continue;
      }
      if (!clsName.endsWith(ENTITY_SUFFIX) && !clsName.endsWith(DTO_SUFFIX)) {
        continue;
      }
      classIndex.set(clsName, cls);
    }
  }
  return classIndex;
}

async function main() {
  process.chdir("/app/");
  const backendProject = new Project({
    tsConfigFilePath: "grassroots-backend/tsconfig.json",
  });

  const sharedProject = new Project({
    tsConfigFilePath: "grassroots-shared/tsconfig.json",
  });

  const thisProject = new Project({
    tsConfigFilePath: "casl-subjects/tsconfig.json",
  });

  const entityIndex = getClassIndex(
    backendProject,
    "/app/grassroots-backend/src",
  );
  const dtoIndex = getClassIndex(sharedProject, "/app/grassroots-shared/src");

  for (const [name, entityClass] of entityIndex) {
    // Look at each entity, and intersect with the DTO of the same name.
    const baseName = name.slice(0, -ENTITY_SUFFIX.length);
    const dtoClass = dtoIndex.get(baseName + DTO_SUFFIX);

    const outPath = path.join("casl-subjects", "gen", `${baseName}Subject.ts`);
    console.log("\n" + baseName);
    const outSourceFile = thisProject.createSourceFile(outPath, "", {
      overwrite: true,
    });
    outSourceFile.insertText(0, `// AUTO-GENERATED by GenerateSubjects.ts\n\n`);

    const entityProps = entityClass.getProperties().map(normalizeProperty);
    const dtoProps = dtoClass?.getProperties().map(normalizeProperty);

    if (!dtoProps) {
      throw new Error(`Missing DTO for Entity ${name}`);
    }

    outSourceFile.addInterface({
      name: `${baseName}Subject`,
      isExported: true,
      properties: intersectProps(entityProps, dtoProps),
    });

    await outSourceFile.save();
  }

  await thisProject.save();
}

main();
